{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _regeneratorRuntime = require(\"/workspaces/MLH-hackathon-project/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/workspaces/MLH-hackathon-project/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/workspaces/MLH-hackathon-project/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/workspaces/MLH-hackathon-project/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/workspaces/MLH-hackathon-project/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/workspaces/MLH-hackathon-project/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/workspaces/MLH-hackathon-project/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/workspaces/MLH-hackathon-project/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/workspaces/MLH-hackathon-project/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\n\nvar stream = require(\"stream\");\n\nvar authclient_1 = require(\"./authclient\");\n\nvar sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\n\n\nvar STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\n\nvar STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\n\nvar STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\n\nvar STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\n\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\n\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\n\nvar DownscopedClient = /*#__PURE__*/function (_authclient_1$AuthCli) {\n  _inherits(DownscopedClient, _authclient_1$AuthCli);\n\n  var _super = _createSuper(DownscopedClient);\n\n  /**\n   * Instantiates a downscoped client object using the provided source\n   * AuthClient and credential access boundary rules.\n   * To downscope permissions of a source AuthClient, a Credential Access\n   * Boundary that specifies which resources the new credential can access, as\n   * well as an upper bound on the permissions that are available on each\n   * resource, has to be defined. A downscoped client can then be instantiated\n   * using the source AuthClient and the Credential Access Boundary.\n   * @param authClient The source AuthClient to be downscoped based on the\n   *   provided Credential Access Boundary rules.\n   * @param credentialAccessBoundary The Credential Access Boundary which\n   *   contains a list of access boundary rules. Each rule contains information\n   *   on the resource that the rule applies to, the upper bound of the\n   *   permissions that are available on that resource and an optional\n   *   condition to further restrict permissions.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   * @param quotaProjectId Optional quota project id for setting up in the\n   *   x-goog-user-project header.\n   */\n  function DownscopedClient(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\n    var _this;\n\n    _classCallCheck(this, DownscopedClient);\n\n    _this = _super.call(this);\n    _this.authClient = authClient;\n    _this.credentialAccessBoundary = credentialAccessBoundary; // Check 1-10 Access Boundary Rules are defined within Credential Access\n    // Boundary.\n\n    if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n      throw new Error('At least one access boundary rule needs to be defined.');\n    } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n      throw new Error('The provided access boundary has more than ' + \"\".concat(exports.MAX_ACCESS_BOUNDARY_RULES_COUNT, \" access boundary rules.\"));\n    } // Check at least one permission should be defined in each Access Boundary\n    // Rule.\n\n\n    var _iterator = _createForOfIteratorHelper(credentialAccessBoundary.accessBoundary.accessBoundaryRules),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var rule = _step.value;\n\n        if (rule.availablePermissions.length === 0) {\n          throw new Error('At least one permission should be defined in access boundary rules.');\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    _this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n    _this.cachedDownscopedAccessToken = null; // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      _this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n    } else {\n      _this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n\n    _this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    _this.quotaProjectId = quotaProjectId;\n    return _this;\n  }\n  /**\n   * Provides a mechanism to inject Downscoped access tokens directly.\n   * The expiry_date field is required to facilitate determination of the token\n   * expiration which would make it easier for the token consumer to handle.\n   * @param credentials The Credentials object to set on the current client.\n   */\n\n\n  _createClass(DownscopedClient, [{\n    key: \"setCredentials\",\n    value: function setCredentials(credentials) {\n      if (!credentials.expiry_date) {\n        throw new Error('The access token expiry_date field is missing in the provided ' + 'credentials.');\n      }\n\n      _get(_getPrototypeOf(DownscopedClient.prototype), \"setCredentials\", this).call(this, credentials);\n\n      this.cachedDownscopedAccessToken = credentials;\n    }\n  }, {\n    key: \"getAccessToken\",\n    value: function () {\n      var _getAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken))) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.refreshAccessTokenAsync();\n\n              case 3:\n                return _context.abrupt(\"return\", {\n                  token: this.cachedDownscopedAccessToken.access_token,\n                  expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n                  res: this.cachedDownscopedAccessToken.res\n                });\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getAccessToken() {\n        return _getAccessToken.apply(this, arguments);\n      }\n\n      return getAccessToken;\n    }()\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n\n  }, {\n    key: \"getRequestHeaders\",\n    value: function () {\n      var _getRequestHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var accessTokenResponse, headers;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getAccessToken();\n\n              case 2:\n                accessTokenResponse = _context2.sent;\n                headers = {\n                  Authorization: \"Bearer \".concat(accessTokenResponse.token)\n                };\n                return _context2.abrupt(\"return\", this.addSharedMetadataHeaders(headers));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getRequestHeaders() {\n        return _getRequestHeaders.apply(this, arguments);\n      }\n\n      return getRequestHeaders;\n    }()\n  }, {\n    key: \"request\",\n    value: function request(opts, callback) {\n      if (callback) {\n        this.requestAsync(opts).then(function (r) {\n          return callback(null, r);\n        }, function (e) {\n          return callback(e, e.response);\n        });\n      } else {\n        return this.requestAsync(opts);\n      }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n\n  }, {\n    key: \"requestAsync\",\n    value: function () {\n      var _requestAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(opts) {\n        var retry,\n            response,\n            requestHeaders,\n            res,\n            statusCode,\n            isReadableStream,\n            isAuthErr,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                retry = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : false;\n                _context3.prev = 1;\n                _context3.next = 4;\n                return this.getRequestHeaders();\n\n              case 4:\n                requestHeaders = _context3.sent;\n                opts.headers = opts.headers || {};\n\n                if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                  opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n                }\n\n                if (requestHeaders && requestHeaders.Authorization) {\n                  opts.headers.Authorization = requestHeaders.Authorization;\n                }\n\n                _context3.next = 10;\n                return this.transporter.request(opts);\n\n              case 10:\n                response = _context3.sent;\n                _context3.next = 27;\n                break;\n\n              case 13:\n                _context3.prev = 13;\n                _context3.t0 = _context3[\"catch\"](1);\n                res = _context3.t0.response;\n\n                if (!res) {\n                  _context3.next = 26;\n                  break;\n                }\n\n                statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n\n                isReadableStream = res.config.data instanceof stream.Readable;\n                isAuthErr = statusCode === 401 || statusCode === 403;\n\n                if (!(!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure)) {\n                  _context3.next = 26;\n                  break;\n                }\n\n                _context3.next = 23;\n                return this.refreshAccessTokenAsync();\n\n              case 23:\n                _context3.next = 25;\n                return this.requestAsync(opts, true);\n\n              case 25:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 26:\n                throw _context3.t0;\n\n              case 27:\n                return _context3.abrupt(\"return\", response);\n\n              case 28:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 13]]);\n      }));\n\n      function requestAsync(_x) {\n        return _requestAsync.apply(this, arguments);\n      }\n\n      return requestAsync;\n    }()\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */\n\n  }, {\n    key: \"refreshAccessTokenAsync\",\n    value: function () {\n      var _refreshAccessTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _a, subjectToken, stsCredentialsOptions, stsResponse, sourceCredExpireDate, expiryDate;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.authClient.getAccessToken();\n\n              case 2:\n                subjectToken = _context4.sent.token;\n                // Construct the STS credentials options.\n                stsCredentialsOptions = {\n                  grantType: STS_GRANT_TYPE,\n                  requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n                  subjectToken: subjectToken,\n                  subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n                }; // Exchange the source AuthClient access token for a Downscoped access\n                // token.\n\n                _context4.next = 6;\n                return this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n\n              case 6:\n                stsResponse = _context4.sent;\n\n                /**\n                 * The STS endpoint will only return the expiration time for the downscoped\n                 * access token if the original access token represents a service account.\n                 * The downscoped token's expiration time will always match the source\n                 * credential expiration. When no expires_in is returned, we can copy the\n                 * source credential's expiration time.\n                 */\n                sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n                expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate; // Save response in cached access token.\n\n                this.cachedDownscopedAccessToken = {\n                  access_token: stsResponse.access_token,\n                  expiry_date: expiryDate,\n                  res: stsResponse.res\n                }; // Save credentials.\n\n                this.credentials = {};\n                Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n                delete this.credentials.res; // Trigger tokens event to notify external listeners.\n\n                this.emit('tokens', {\n                  refresh_token: null,\n                  expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n                  access_token: this.cachedDownscopedAccessToken.access_token,\n                  token_type: 'Bearer',\n                  id_token: null\n                }); // Return the cached access token.\n\n                return _context4.abrupt(\"return\", this.cachedDownscopedAccessToken);\n\n              case 15:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function refreshAccessTokenAsync() {\n        return _refreshAccessTokenAsync.apply(this, arguments);\n      }\n\n      return refreshAccessTokenAsync;\n    }()\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n\n  }, {\n    key: \"isExpired\",\n    value: function isExpired(downscopedAccessToken) {\n      var now = new Date().getTime();\n      return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n  }]);\n\n  return DownscopedClient;\n}(authclient_1.AuthClient);\n\nexports.DownscopedClient = DownscopedClient;","map":{"version":3,"sources":["/workspaces/MLH-hackathon-project/frontend/node_modules/google-auth-library/build/src/auth/downscopedclient.js"],"names":["Object","defineProperty","exports","value","DownscopedClient","EXPIRATION_TIME_OFFSET","MAX_ACCESS_BOUNDARY_RULES_COUNT","stream","require","authclient_1","sts","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","STS_SUBJECT_TOKEN_TYPE","STS_ACCESS_TOKEN_URL","authClient","credentialAccessBoundary","additionalOptions","quotaProjectId","accessBoundary","accessBoundaryRules","length","Error","rule","availablePermissions","stsCredential","StsCredentials","cachedDownscopedAccessToken","eagerRefreshThresholdMillis","forceRefreshOnFailure","credentials","expiry_date","isExpired","refreshAccessTokenAsync","token","access_token","expirationTime","res","getAccessToken","accessTokenResponse","headers","Authorization","addSharedMetadataHeaders","opts","callback","requestAsync","then","r","e","response","retry","getRequestHeaders","requestHeaders","transporter","request","statusCode","status","isReadableStream","config","data","Readable","isAuthErr","subjectToken","stsCredentialsOptions","grantType","requestedTokenType","subjectTokenType","exchangeToken","undefined","stsResponse","sourceCredExpireDate","_a","expiryDate","expires_in","Date","getTime","assign","emit","refresh_token","token_type","id_token","downscopedAccessToken","now","AuthClient"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\nconst stream = require(\"stream\");\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\nconst STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\nclass DownscopedClient extends authclient_1.AuthClient {\n    /**\n     * Instantiates a downscoped client object using the provided source\n     * AuthClient and credential access boundary rules.\n     * To downscope permissions of a source AuthClient, a Credential Access\n     * Boundary that specifies which resources the new credential can access, as\n     * well as an upper bound on the permissions that are available on each\n     * resource, has to be defined. A downscoped client can then be instantiated\n     * using the source AuthClient and the Credential Access Boundary.\n     * @param authClient The source AuthClient to be downscoped based on the\n     *   provided Credential Access Boundary rules.\n     * @param credentialAccessBoundary The Credential Access Boundary which\n     *   contains a list of access boundary rules. Each rule contains information\n     *   on the resource that the rule applies to, the upper bound of the\n     *   permissions that are available on that resource and an optional\n     *   condition to further restrict permissions.\n     * @param additionalOptions Optional additional behavior customization\n     *   options. These currently customize expiration threshold time and\n     *   whether to retry on 401/403 API request errors.\n     * @param quotaProjectId Optional quota project id for setting up in the\n     *   x-goog-user-project header.\n     */\n    constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\n        super();\n        this.authClient = authClient;\n        this.credentialAccessBoundary = credentialAccessBoundary;\n        // Check 1-10 Access Boundary Rules are defined within Credential Access\n        // Boundary.\n        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n            throw new Error('At least one access boundary rule needs to be defined.');\n        }\n        else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length >\n            exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n            throw new Error('The provided access boundary has more than ' +\n                `${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);\n        }\n        // Check at least one permission should be defined in each Access Boundary\n        // Rule.\n        for (const rule of credentialAccessBoundary.accessBoundary\n            .accessBoundaryRules) {\n            if (rule.availablePermissions.length === 0) {\n                throw new Error('At least one permission should be defined in access boundary rules.');\n            }\n        }\n        this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n        this.cachedDownscopedAccessToken = null;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n        this.quotaProjectId = quotaProjectId;\n    }\n    /**\n     * Provides a mechanism to inject Downscoped access tokens directly.\n     * The expiry_date field is required to facilitate determination of the token\n     * expiration which would make it easier for the token consumer to handle.\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        if (!credentials.expiry_date) {\n            throw new Error('The access token expiry_date field is missing in the provided ' +\n                'credentials.');\n        }\n        super.setCredentials(credentials);\n        this.cachedDownscopedAccessToken = credentials;\n    }\n    async getAccessToken() {\n        // If the cached access token is unavailable or expired, force refresh.\n        // The Downscoped access token will be returned in\n        // DownscopedAccessTokenResponse format.\n        if (!this.cachedDownscopedAccessToken ||\n            this.isExpired(this.cachedDownscopedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return Downscoped access token in DownscopedAccessTokenResponse format.\n        return {\n            token: this.cachedDownscopedAccessToken.access_token,\n            expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n            res: this.cachedDownscopedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        const accessTokenResponse = await this.getAccessToken();\n        const headers = {\n            Authorization: `Bearer ${accessTokenResponse.token}`,\n        };\n        return this.addSharedMetadataHeaders(headers);\n    }\n    request(opts, callback) {\n        if (callback) {\n            this.requestAsync(opts).then(r => callback(null, r), e => {\n                return callback(e, e.response);\n            });\n        }\n        else {\n            return this.requestAsync(opts);\n        }\n    }\n    /**\n     * Authenticates the provided HTTP request, processes it and resolves with the\n     * returned response.\n     * @param opts The HTTP request options.\n     * @param retry Whether the current attempt is a retry after a failed attempt.\n     * @return A promise that resolves with the successful response.\n     */\n    async requestAsync(opts, retry = false) {\n        let response;\n        try {\n            const requestHeaders = await this.getRequestHeaders();\n            opts.headers = opts.headers || {};\n            if (requestHeaders && requestHeaders['x-goog-user-project']) {\n                opts.headers['x-goog-user-project'] =\n                    requestHeaders['x-goog-user-project'];\n            }\n            if (requestHeaders && requestHeaders.Authorization) {\n                opts.headers.Authorization = requestHeaders.Authorization;\n            }\n            response = await this.transporter.request(opts);\n        }\n        catch (e) {\n            const res = e.response;\n            if (res) {\n                const statusCode = res.status;\n                // Retry the request for metadata if the following criteria are true:\n                // - We haven't already retried.  It only makes sense to retry once.\n                // - The response was a 401 or a 403\n                // - The request didn't send a readableStream\n                // - forceRefreshOnFailure is true\n                const isReadableStream = res.config.data instanceof stream.Readable;\n                const isAuthErr = statusCode === 401 || statusCode === 403;\n                if (!retry &&\n                    isAuthErr &&\n                    !isReadableStream &&\n                    this.forceRefreshOnFailure) {\n                    await this.refreshAccessTokenAsync();\n                    return await this.requestAsync(opts, true);\n                }\n            }\n            throw e;\n        }\n        return response;\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Then GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */\n    async refreshAccessTokenAsync() {\n        var _a;\n        // Retrieve GCP access token from source credential.\n        const subjectToken = (await this.authClient.getAccessToken()).token;\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken: subjectToken,\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE,\n        };\n        // Exchange the source AuthClient access token for a Downscoped access\n        // token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n        /**\n         * The STS endpoint will only return the expiration time for the downscoped\n         * access token if the original access token represents a service account.\n         * The downscoped token's expiration time will always match the source\n         * credential expiration. When no expires_in is returned, we can copy the\n         * source credential's expiration time.\n         */\n        const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n        const expiryDate = stsResponse.expires_in\n            ? new Date().getTime() + stsResponse.expires_in * 1000\n            : sourceCredExpireDate;\n        // Save response in cached access token.\n        this.cachedDownscopedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: expiryDate,\n            res: stsResponse.res,\n        };\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n            access_token: this.cachedDownscopedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedDownscopedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(downscopedAccessToken) {\n        const now = new Date().getTime();\n        return downscopedAccessToken.expiry_date\n            ? now >=\n                downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.DownscopedClient = DownscopedClient;\n//# sourceMappingURL=downscopedclient.js.map"]},"metadata":{},"sourceType":"script"}